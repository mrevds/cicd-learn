name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.20'

      - name: Run tests
        run: go test -v ./...

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/learncicd:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/learncicd:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            # Переходим в рабочую директорию
            cd /opt/cicd-learn || mkdir -p /opt/cicd-learn && cd /opt/cicd-learn
            
            # Клонируем или обновляем репозиторий
            if [ -d ".git" ]; then
              git pull origin main
            else
              git clone https://github.com/${{ github.repository }} .
            fi
            
            # Останавливаем старые контейнеры
            docker-compose -f docker-compose.prod.yml down || true
            
            # Очищаем старые образы приложения (кроме postgres)
            docker images ${{ secrets.DOCKERHUB_USERNAME }}/learncicd -q | xargs -r docker rmi -f
            
            # Создаем .env файл для продакшена
            echo "DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}" > .env
            
            # Загружаем свежий образ из DockerHub
            docker-compose -f docker-compose.prod.yml pull app
            
            # Запускаем контейнеры
            docker-compose -f docker-compose.prod.yml up -d
            
            # Ждем запуска PostgreSQL
            sleep 15
            
            # Создаем базу данных если её нет
            POSTGRES_CONTAINER=$(docker-compose -f docker-compose.prod.yml ps -q postgres)
            docker exec -i $POSTGRES_CONTAINER psql -U postgres -c "SELECT 1 FROM pg_database WHERE datname = 'cicd_learn';" | grep -q 1 || \
            docker exec -i $POSTGRES_CONTAINER psql -U postgres -c "CREATE DATABASE cicd_learn;"
            
            # Перезапускаем приложение после создания БД
            docker-compose -f docker-compose.prod.yml restart app
            
            # Ждем запуска приложения
            sleep 10
            
            # Проверяем статус контейнеров
            docker-compose -f docker-compose.prod.yml ps
            
            # Тестируем API
            curl -f http://localhost:8080/ping && echo " ✅ API работает!" || echo " ❌ API не отвечает"
            
            # Проверяем что можем получить книги
            curl -f http://localhost:8080/books && echo " ✅ База данных работает!" || echo " ❌ Проблема с БД"

